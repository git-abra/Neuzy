%% POIRAZI MODEL
clear all; clc;
% initialize model folder hierarchy in current folder:
t2n_initModelfolders     (pwd);
tstop                    = 2100;
dt                       = 0.05;
options                  = struct;
options.region           = 'p';  % include -axon if the cells have an axon
options.typemodel        = 'act';
options.insertka         = 'yes';    % or 'no'
options.insertcalH       = 'yes';    % or 'no'
% NOTE: no modifications to account for spines in this model

%% Define standard parameters
neuron.params            = [];
neuron.params.celsius    = 34;
neuron.params.v_init     = -70;
neuron.params.prerun     = 200;
neuron.params.tstop      = tstop;
neuron.params.dt         = dt;
neuron.params.nseg       = 'Each 75';
neuron.experiment        = 'out';

%% Load morphology
[tree, treeFilename, treepath] = load_tree ( ...
    './morphos/hPCs_Poirazi1.mtr');
tname                    = 'Poirazi_model';
neuron.params.exchfolder = 't2nexchange_Poirazi_model';
% to de-group the morphologies (if necessary), and have the different tree
% structures in the cell array 'tree':
if isstruct              (tree)
    tree                 = {tree};
elseif iscell            (tree{1})
    tree                 = tree{1};
end
%% Divide the tree morphology (if it hasn't been divided before)
% for t                    = 1 : numel (tree)
%     % option p poirazi
%     tree{t}              = CA1pyramidalcell_sort_PP(tree{t},'-p');
% end
%% Convert the tree into NEURON
if      ~all (cellfun (@(x) isfield (x, 'NID'), tree)) || ...
        ~all (cellfun (@(x) ...
        exist (fullfile (pwd, 'morphos', 'hocs', [x.NID, '.hoc']), 'file'), ...
        tree))
    answer               = questdlg ([ ...
        'Caution! Not all of your tree have been transformed for NEURON yet!' ...
        'Transforming now..'], 'Transform tree', 'OK', 'Cancel', 'OK');
    % If I want to convert my tree into hoc, sort them first, and then do
    % it:
    if strcmp            (answer, 'OK')
%         for t            = 1 : numel (tree)
%             tree{t}      = sort_tree (tree{t}, '-LO');
%         end
        % Tanslation of morphologies into hoc file:
        tree             = t2n_writeTrees ( ...
            tree, tname, fullfile (treepath, treeFilename));
    end
end

%% Calculations needed to set the parameters
% (specific from Poirazi's model)
for t                    = 1 : numel (tree)
    [basalnode(t), apicalnode(t)]                = ...
        calculate_basalapicalnode (tree{t});
    
    [trunk_branchpoints{t}, peritrunk_branch{t}] = ...
        find_peritrunknodes (tree{t});
    
    [idnodes300{t}, idnodes350{t}]               = ...
        getdistalnodesPP (tree{t});
    
    treenodes{t}         = (1 : numel (tree{t}.X))';
end

%% Add passive parameters
Cm_default               = 1;         % Membrane capacitance (?F/cm?)
v_init                   = -70;       % in mV; Initial voltage of the sections
e_pas                    = v_init;
Rm_default               = 200000;    % in ohmcm? -> 200 Kohmcm? Poirazi et al. 2003
Rm_end                   = 12000;     % in ohmcm? -> 12 Kohmcm? Poirazi et al. 2003
Rm_dhalf                 = 200;       % in um
Rm_steep                 = 50;        % in um
Ri_default               = 50;        % in ohmcm?
Ri_end                   = 35;        % in ohmcm?
Ri_dhalf                 = 210;       % in um
Ri_steep                 = 50;        % in um
% ******************* Scaling the original sigmoid from Poirazi's model:
for t                    = 1 : numel (tree)
    Rm_sigmoid{t}        = getPPsigmoid (tree{t}, ...
        Rm_default, Rm_end, Rm_dhalf, Rm_steep);
    Ri_sigmoid{t}        = getPPsigmoid (tree{t}, ...
        Ri_default, Ri_end, Ri_dhalf, Ri_steep);
    % ******************* Adding to the sigmoid the value of the
    % peritrunk area. The Ra does not include the peritrunk area
    Rm_sigmoid_p{t}      = addPeritrunkval (treenodes{t}, ...
        trunk_branchpoints{t}, peritrunk_branch{t}, Rm_sigmoid{t});
    % ******************* Inserting the mechanisms
    % trunk and peritrunk values are included in the ranged variable:
    neuron.mech{t}.range.pas        = struct ( ...
        'g',                   1./ Rm_sigmoid_p{t});
    neuron.mech{t}.trunk.pas        = struct ( ...
        'cm',                  Cm_default, ...
        'Ra',                  Ri_default, ...
        'g',                   1 / Rm_default, ...
        'e',                   e_pas);
    neuron.mech{t}.peritrunk.pas    = struct ( ...
        'cm',                  Cm_default, ...
        'Ra',                  Ri_default, ...
        'g',                   1 / Rm_default, ...
        'e',                   e_pas);
    neuron.mech{t}.soma.pas         = struct ( ...
        'cm',                  Cm_default, ...
        'Ra',                  Ri_default, ...
        'g',                   1 / Rm_default, ...
        'e',                   e_pas);
    neuron.mech{t}.basal.pas        = struct ( ...
        'cm',                  Cm_default, ...
        'Ra',                  Ri_default, ...
        'g',                   1 / Rm_sigmoid_p{t} (basalnode (t)), ...
        'e',                   e_pas);
    neuron.mech{t}.apical.pas       = struct ( ...
        'cm',                  Cm_default, ...
        'Ra',                  Ri_default, ...
        'g',                   1 / Rm_sigmoid_p{t} (apicalnode (t)), ...
        'e',                   e_pas);
    if  contains               (options.region, '-axon')
        neuron.mech{t}.hill.pas     = struct ( ...
            'cm',              Cm_default, ...
            'Ra',              Ri_default, ...
            'g',               1 / Rm_default, ...
            'e',               e_pas);
        neuron.mech{t}.iseg.pas     = struct ( ...
            'cm',              Cm_default, ...
            'Ra',              Ri_default, ...
            'g',               1 / Rm_default, ...
            'e',               e_pas);
        neuron.mech{t}.node.pas     = struct ( ...
            'cm',              Cm_default, ...
            'Ra',              Ri_default, ...
            'g',               1 / Rm_default, ...
            'e',               e_pas);
        neuron.mech{t}.myelin.pas   = struct ( ...
            'cm',              Cm_default, ...
            'Ra',              Ri_default, ...
            'g',               1 / Rm_default, ...
            'e',               e_pas);
    end
end

%% Add active mechanisms
if  contains             (options.typemodel, 'act')
    for t                = 1 : numel (tree)
        % ---------- Voltage-dependent Na+ current and delayed rectifier ----------
        gna_default      = 0.007;    % in mho(S)/cm2
        gna_axon         = 0.1;      % in mho(S)/cm2
        trunk_non_trunk_ratio = 1.0;
        % Delayed rectifier properties as percentage of Na conductance
        kdr_div          = 10.0 / 1.24;
        kdr_div_soma     = 10.0 / 2.0;
        % Delayed rectifier conductances
        gkdrbar_default  = gna_default / kdr_div;
        gkdrbar_soma     = gna_default / kdr_div_soma;
        gkdrbar_axon     = gna_axon    / kdr_div_soma;
        % Activity dependent attenuation calculation (ar2 parameter):0 is
        % maximum attenuation, 1 is no attenuation. Along the apical trunk
        min_ar2          = 0.30;
        max_ar2          = 0.95;
        decay_start      = 50;
        decay_end        = 300;
        ar2_hha_old_linear{t}   = getPPar2        (tree{t}, ...
            min_ar2, max_ar2, decay_start, decay_end);
        
        % Adding to the sigmoid the value of the peritrunk area:
        ar2_hha_old_linear_p{t} = addPeritrunkval (treenodes{t}, ...
            trunk_branchpoints{t}, ...
            peritrunk_branch{t}, ...
            ar2_hha_old_linear{t});
        
        % Apical value of conductances: for distances > 350um
        for node         = 1 : numel (ar2_hha_old_linear_p{t})
            if sum (ismember (idnodes350{t}, node)) == 1
                % change the more distal apical nodes values. The lss
                % distal apical nodes, take the value of the apical
                % dendrite 46:
                ar2_hha_old_linear_p{t} (node, 1) = 0.95;
                gkdrbar_hha_old{t} (node, 1) = 1.07 * gkdrbar_default;
            else
                gkdrbar_hha_old{t} (node, 1) = NaN;
            end
        end
        % trunk, peritrunk and apical (distances more than 350um) nodes are
        % included in the range variable. Only distal apical in th case of
        % kdr channel:
        neuron.mech{t}.range.hha_old        = struct ( ...
            'gkbar',           gkdrbar_hha_old{t}, ...
            'ar2',             ar2_hha_old_linear_p{t});
        neuron.mech{t}.trunk.hha_old        = struct ( ...
            'gnabar',          gna_default, ...
            'gkbar',           gkdrbar_default, ...
            'ar2',             1, ...
            'gl',              0, ...
            'el',              v_init, ...
            'ena',             50, ...
            'ek',              -77);
        neuron.mech{t}.peritrunk.hha_old    = struct ( ...
            'gnabar',          gna_default, ...
            'gkbar',           gkdrbar_default, ...
            'ar2',             1, ...
            'gl',              0, ...
            'el',              v_init, ...
            'ena',             50, ...
            'ek',              -77);
        neuron.mech{t}.apical.hha_old       = struct ( ...
            'gnabar',          trunk_non_trunk_ratio*gna_default, ...
            'gkbar',           gkdrbar_default, ...
            'ar2',             0.8*ar2_hha_old_linear_p{t}(apicalnode(t)), ...
            'gl',              0, ...
            'el',              v_init, ...
            'ena',             50, ...
            'ek',              -77);    % set to 80% of the dend.46 value
        neuron.mech{t}.basal.hha_old        = struct ( ...
            'gnabar',          gna_default, ...
            'gkbar',           gkdrbar_default, ...
            'ar2',             1, ...
            'W',               0.016, ...
            'gl',              0, ...
            'el',              v_init, ...
            'ena',             50, ...
            'ek',              -77);
        neuron.mech{t}.soma.hha2            = struct ( ...
            'gnabar',          gna_default, ...
            'gkbar',           gkdrbar_soma, ...
            'ar2',             1, ...
            'W',               0.016, ...
            'gl',              0, ...
            'el',              v_init, ...
            'ena',             50, ...
            'ek',              -77);
        % ---------- Hyperpolarization activated current (uses Na+ ions) ----------
        gh_default       = 1.872e-5;   % in mho/cm2
        gh_end           = gh_default * 9;
        gh_dhalf         = 280;
        gh_steep         = 50;
        K                = 8.8;
        % Sigmoidally decreasing H-current distribution: along apical trunk.
        h_sigmoid{t}     = getPPsigmoid    (tree{t}, ...
            gh_default, gh_end, gh_dhalf, gh_steep);
        
        % Peritrunk values of conductances: value from each branch node in
        % the trunk -> for distances close to the parent trunk section keep
        % trunk values:
        h_sigmoid_p{t}   = addPeritrunkval (treenodes{t}, ...
            trunk_branchpoints{t}, peritrunk_branch{t}, h_sigmoid{t});
        
        % trunk a peritrunk nodes are included in the range variable:
        neuron.mech{t}.range.h              = struct ( ...
            'gbar',            h_sigmoid_p{t});
        neuron.mech{t}.trunk.h              = struct ( ...
            'gbar',            gh_default, ...
            'eh',              -10, ...
            'ena',             50);
        neuron.mech{t}.peritrunk.h          = struct ( ...
            'gbar',            gh_default, ...
            'eh',              -10, ...
            'ena',             50);
        neuron.mech{t}.apical.h             = struct ( ...
            'gbar',            h_sigmoid_p{t}(apicalnode(t)), ...
            'eh',              -10, ...
            'ena',             50);
        neuron.mech{t}.soma.h               = struct ( ...
            'gbar',            gh_default, ...
            'K',               K, ...
            'vhalf',           -82, ...
            'eh',              -10, ...
            'ena',             50);
        % does not get the value of the apical dendrite 14:
        neuron.mech{t}.basal.h              = struct ( ...
            'gbar',            gh_default, ...
            'eh',              -10, ...
            'ena',             50);
        % ------------------ Fast inactivating potassium current ------------------
        if contains      (options.insertka, 'yes')
            soma_kap     = 0.0075;              % in mho(S)/cm2
            kad_init     = 1.04 * 0.0072;         % in mho(S)/cm2
            kap_distal_distance  = 100;      % in um
            kad_distal_maxfactor = 6.5;
            kad_distal_distance  = 350;      % in um
            % Distribution function: only for the apical trunk
            [gkabar_kap_fixed{t}, gkabar_kad_linear{t}] = getPPka (tree{t}, ...
                soma_kap,kad_init,   kap_distal_distance, ...
                kad_distal_distance, kad_distal_maxfactor);
            
            % Peritrunk values of conductances: value from each branch node
            % in the trunk -> for distances close to the parent trunk
            % section keep trunk values:
            gkabar_kap_fixed_p{t}   = addPeritrunkval (treenodes{t}, ...
                trunk_branchpoints{t}, peritrunk_branch{t}, gkabar_kap_fixed{t});
            gkabar_kad_linear_p{t}  = addPeritrunkval (treenodes{t}, ...
                trunk_branchpoints{t}, peritrunk_branch{t}, gkabar_kad_linear{t});
            
            % Apical value of conductances: for distances > 300um for Kad
            for node     = 1 : numel (gkabar_kad_linear_p{t})
                if sum   (ismember (idnodes300{t}, node)) == 1
                    % change the more distal apical nodes values. The lss
                    % distal apical nodes, take the value of the apical
                    % dendrite 46:
                    gkabar_kad_linear_p{t}(node, 1) = ...
                        gkabar_kad_linear_p{t}(apicalnode (t)) * 1.3 * 1.9;
                end
            end
            % includes the trunk, peritrunk and further than 300um apicl
            % nodes:
            neuron.mech{t}.range.kap        = struct ( ...
                'gkabar',      gkabar_kap_fixed_p{t});
            neuron.mech{t}.range.kad        = struct ( ...
                'gkabar',      gkabar_kad_linear_p{t});
            neuron.mech{t}.trunk.kap        = struct ( ...
                'gkabar',      soma_kap, ...
                'ek',          -80);
            neuron.mech{t}.trunk.kad        = struct ( ...
                'gkabar',      soma_kap, ...
                'ek',          -80);
            neuron.mech{t}.peritrunk.kap    = struct ( ...
                'gkabar',      soma_kap, ...
                'ek',          -80);
            neuron.mech{t}.peritrunk.kad    = struct ( ...
                'gkabar',      soma_kap, ...
                'ek',          -80);
            neuron.mech{t}.apical.kap       = struct ( ...
                'gkabar',      gkabar_kap_fixed_p{t}  (apicalnode(t)), ...
                'ek',          -80); % this should be zero
            neuron.mech{t}.apical.kad       = struct ( ...
                'gkabar',      gkabar_kad_linear_p{t} (apicalnode(t)) * 1.25, ...
                'ek',          -80);
            neuron.mech{t}.soma.kap         = struct ( ...
                'gkabar',      soma_kap, ...
                'ek',          -80); % no kad in soma
            neuron.mech{t}.basal.kap        = struct ( ...
                'gkabar',      gkabar_kap_fixed_p{t}  (basalnode(t)) * 1.6, ...
                'ek',          -80);
            neuron.mech{t}.basal.kad        = struct ( ...
                'gkabar',      gkabar_kap_fixed_p{t}  (basalnode(t)) * 1.6, ...
                'ek',          -80);
        end
        % ---------------- Slow, noninactivating m-type K+ current ----------------
        % Fixed conductance along the apical trunk
        soma_km          = 0.06;     % mho(S)/cm2
        neuron.mech{t}.soma.km              = struct ( ...
            'gbar',            soma_km, ...
            'ek',              -80);
        neuron.mech{t}.trunk.km             = struct ( ...
            'gbar',            soma_km, ...
            'ek',              -80);
        neuron.mech{t}.peritrunk.km         = struct ( ...
            'gbar',            soma_km, ...
            'ek',              -80);
        neuron.mech{t}.apical.km            = struct ( ...
            'gbar',            soma_km * 2, ...
            'ek',              -80);
        
        % -------- L-type calcium channel with low threshold for activation -------
        % Only in the soma
        soma_caL         = 0.014;    % mho(S)/cm2
        neuron.mech{t}.soma.cal             = struct ( ...
            'gcalbar',         soma_caL / 2);  % only in the soma
        
        % -------- L-type calcium channel with high treshold of activation --------
        % L-type current is distributed in a maximum fixed conductance for
        % distances xdist > 50 um and in a very small conductance for xdist
        % < 50 um
        if contains      (options.insertcalH, 'yes')
            soma_caLH    = 0.95 * 0.000333;     % in mho/cm2
            gcalbar_calH{t}   = getPPcalH       (tree{t}, ...
                soma_caLH);
            
            % Peritrunk values of conductances: value from each branch node
            % in the trunk -> for distances close to the parent trunk
            % section keep trunk values:
            gcalbar_calH_p{t} = addPeritrunkval (treenodes{t}, ...
                trunk_branchpoints{t}, peritrunk_branch{t}, gcalbar_calH{t});
            
            % Apical value of conductances: for distances > 300um for Kad
            for node     = 1 : numel (gcalbar_calH_p{t})
                if sum   (ismember (idnodes300{t}, node)) == 1
                    % change the more distal apical nodes values. The
                    % lss distal apical nodes, take the value of the
                    % apical dendrite 46:
                    gcalbar_calH_p{t} (node, 1) = soma_caLH * 14;
                end
                if sum   (ismember (idnodes350{t}, node)) == 1
                    % change the more distal apical nodes values. The lss
                    % distal apical nodes, take the value of the apical
                    % dendrite 46:
                    gcalbar_calH_p{t} (node, 1) = soma_caLH * 15;
                end
            end
            % includes the trunk, peritrunk and further than 300-350um
            % apical nodes:
            neuron.mech{t}.range.calH       = struct ( ...
                'gcalbar',     gcalbar_calH_p{t});
            neuron.mech{t}.trunk.calH       = struct ( ...
                'gcalbar',     soma_caLH, ...
                'eca',         140);
            neuron.mech{t}.peritrunk.calH   = struct ( ...
                'gcalbar',     soma_caLH, ...
                'eca',         140);
            neuron.mech{t}.apical.calH      = struct ( ...
                'gcalbar',     soma_caLH, ...
                'eca',         140);
        end
        
        % ------- T-type calcium channel with high threshold for activation -------
        % Inserting LVA Ca++ T-type channels along the apical trunk in a
        % linearly increasing manner, for xdist > 100 um:
        soma_caT         = 0.0001;  % mho(S)/cm2
        caT_distal_maxfactor = 4;
        caT_distal_distance  = 350;
        gcatbar_cat{t}       = getPPcat (tree{t}, ...
            soma_caT, caT_distal_distance, caT_distal_maxfactor);
        
        % Peritrunk values of conductances: value from each branch node in
        % the trunk -> for distances close to the parent trunk section keep
        % trunk values:
        gcatbar_cat_p{t}     = addPeritrunkval (treenodes{t}, ...
            trunk_branchpoints{t}, ...
            peritrunk_branch{t}, ...
            gcatbar_cat{t});
        
        neuron.mech{t}.range.cat            = struct ( ...
            'gcatbar',         gcatbar_cat_p{t});
        neuron.mech{t}.trunk.cat            = struct ( ...
            'gcatbar',         soma_caT);
        neuron.mech{t}.peritrunk.cat        = struct ( ...
            'gcatbar',         soma_caT);
        neuron.mech{t}.apical.cat           = struct ( ...
            'gcatbar',         gcatbar_cat_p{t} (apicalnode (t)));
        neuron.mech{t}.soma.cat             = struct ( ...
            'gcatbar',         soma_caT / 2);
        
        % --------- Ca R-type channel with medium threshold for activation --------
        % Only in the soma
        gsomacar         = 0.003;   % mho(S)/cm2
        neuron.mech{t}.soma.somacar         = struct ( ...
            'gcabar',          gsomacar, ...
            'eca',             140);
        % Only in the dendrites, and ranged in distal areas
        init_car         = 0.0003;   % in mho(S)/cm2
        trunk_car        = init_car * 0.1;
        for node         = 1 : numel (treenodes{t})
            if sum       (ismember (idnodes300{t}, node)) == 1
                % change the more distal apical nodes values. The lss
                % distal apical nodes, take the value of the apical
                % dendrite 46:
                gcabar_car{t} (node, 1) = 13 * init_car;
            else
                gcabar_car{t} (node, 1) = NaN;
            end
        end
        neuron.mech{t}.range.car            = struct ( ...
            'gcabar',          gcabar_car{t});  % Only apical included
        neuron.mech{t}.apical.car           = struct ( ...
            'gcabar',          init_car, ...
            'eca',             140);
        neuron.mech{t}.trunk.car            = struct ( ...
            'gcabar',          trunk_car, ...
            'eca',             140);
        neuron.mech{t}.peritrunk.car        = struct ( ...
            'gcabar',          trunk_car, ...
            'eca',             140);
        
        % ---- Slow (kca) and Medium (mykca) AHP Ca-dependent potassium current ---
        soma_kca         = 0.0001;  % mho/cm2
        soma_cagk        = 1.1 * 0.015;
        % distance in dendrites for maximum conductance:
        kca_distal_distance = 200;
        [gkbar_cagk{t}, gbar_kca{t}] = getPPkca (tree{t}, ...
            soma_kca,soma_cagk, ...
            kca_distal_distance);
        
        % Peritrunk values of conductances: value from each branch node in
        % the trunk -> for distances close to the parent trunk section keep
        % trunk values:
        gkbar_cagk_p{t}   = addPeritrunkval (treenodes{t}, ...
            trunk_branchpoints{t}, ...
            peritrunk_branch{t}, ...
            gkbar_cagk{t});
        gbar_kca_p{t}     = addPeritrunkval (treenodes{t}, ...
            trunk_branchpoints{t}, ...
            peritrunk_branch{t}, ...
            gbar_kca{t});
        
        % Apical value of conductances: for distances > 300um
        for node         = 1 : numel (gbar_kca_p{t})
            if sum       (ismember (idnodes300{t}, node)) == 1
                % change the more distal apical nodes values. The lss
                % distal apical nodes, take the value of the apical
                % dendrite 46:
                gbar_kca_p{t}(node, 1)  = soma_kca * 5;
            end
        end
        % includes the trunk, peritrunk,and far apical:
        neuron.mech{t}.range.kca        = struct ( ...
            'gbar',            gbar_kca_p{t});
        neuron.mech{t}.trunk.kca        = struct ( ...
            'gbar',            soma_kca, ...
            'ek',              -80);
        neuron.mech{t}.peritrunk.kca    = struct ( ...
            'gbar',            soma_kca, ...
            'ek',              -80);
        neuron.mech{t}.apical.kca       = struct ( ...
            'gbar',            gbar_kca_p{t} (apicalnode (t)), ...
            'ek',              -80);
        neuron.mech{t}.soma.kca         = struct ( ...
            'gbar',            5 * soma_kca, ...
            'ek',              -80);
        % includes the trunk, peritrunk:
        neuron.mech{t}.range.mykca      = struct ( ...
            'gkbar',           gkbar_cagk_p{t});
        neuron.mech{t}.trunk.mykca      = struct ( ...
            'gkbar',           soma_cagk, ...
            'ek',             -80);
        neuron.mech{t}.peritrunk.mykca  = struct ( ...
            'gkbar',           soma_cagk, ...
            'ek',             -80);
        neuron.mech{t}.apical.mykca     = struct ( ...
            'gkbar',           soma_cagk * 1.1, ...
            'ek',             -80);
        neuron.mech{t}.soma.mykca       = struct ( ...
            'gkbar',           soma_cagk * 5.5, ...
            'ek',             -80);
        
        % ---------------------- Calcium buffering mechanism ----------------------
        neuron.mech{t}.soma.cad        = struct ( ...
            'depth',           0.1, ...
            'taur',            200, ...
            'cainf',           0.0001);
        neuron.mech{t}.trunk.cad       = struct ( ...
            'depth',           0.1, ...
            'taur',            200, ...
            'cainf',           0.0001);
        neuron.mech{t}.peritrunk.cad   = struct ( ...
            'depth',           0.1, ...
            'taur',            200, ...
            'cainf',           0.0001);
        neuron.mech{t}.apical.cad      = struct ( ...
            'depth',           0.1, ...
            'taur',            200, ...
            'cainf',           0.0001);
        
        % ------------------------- Na+ persistent channel ----------------
        gna_default = 0.007;
        apdend_nap = 0.0004*gna_default;   % holding value of the apical dend 46
        trunk_nap = 0.2*apdend_nap;    % only a small percentage in the trunk
        % Apical value of conductances: for distances > 300um
        for node = 1:numel(treenodes{t})
            if sum(ismember(idnodes350{t}, node)) == 1
                % change the more distal apical nodes values. The lss
                % distal apical nodes, take the value of the apical
                % dendrite 46:
                gbar_nap{t}(node,1) = apdend_nap*2;
            else
                gbar_nap{t}(node,1) = NaN;
            end
        end
        % Inserting the current: no included in basal, axon, trunk and soma
        neuron.mech{t}.range.nap      = struct ( ...
            'gnabar',          gbar_nap{t});   % included apical region
        neuron.mech{t}.peritrunk.nap  = struct ( ...
            'gnabar',          trunk_nap, ...
            'ena',             50);
        neuron.mech{t}.apical.nap     = struct ( ...
            'gnabar',          apdend_nap, ...
            'ena',             50);
        
        % ----------------------- INSERTING THE MECHANISMS IN THE AXON ----
        if  contains(options.region,'-axon')
            neuron.mech{t}.hill.hha2        = struct ( ...
                'gnabar',      gna_axon, ...
                'gkbar',       gkdrbar_axon, ...
                'ar2',         1, ...
                'W',           0.016, ...
                'gl',          0, ...
                'el',          v_init, ...
                'ena',         50, ...
                'ek',          -77);
            neuron.mech{t}.iseg.hha2        = struct ( ...
                'gnabar',      gna_axon, ...
                'gkbar',       gkdrbar_axon, ...
                'ar2',         1, ...
                'W',           0.016, ...
                'gl',          0, ...
                'el',          v_init, ...
                'ena',         50, ...
                'ek',          -77);
            neuron.mech{t}.node.hha2        = struct ( ...
                'gnabar',      gna_axon, ...
                'gkbar',       gkdrbar_axon, ...
                'ar2',         1, ...
                'W',           0.016, ...
                'gl',          0, ...
                'el',          v_init, ...
                'ena',         50, ...
                'ek',          -77);
            neuron.mech{t}.myelin.hha2      = struct ( ...
                'gnabar',      gna_axon, ...
                'gkbar',       gkdrbar_axon, ...
                'ar2',         1, ...
                'W',           0.016, ...
                'gl',          0, ...
                'el',          v_init, ...
                'ena',         50, ...
                'ek',          -77);
            neuron.mech{t}.hill.km          = struct ( ...
                'gbar',        0.5 * soma_km, ...
                'ek',          -80);
            neuron.mech{t}.iseg.km          = struct ( ...
                'gbar',        0.5 * soma_km, ...
                'ek',          -80);
            neuron.mech{t}.node.km          = struct ( ...
                'gbar',        0.5 * soma_km, ...
                'ek',          -80);
            neuron.mech{t}.myelin.km        = struct ( ...
                'gbar',        0.5 * soma_km, ...
                'ek',          -80);
        end
    end
end
neuron_orig              = neuron;

%% DENDRITIC CONSTANCY EXP. POISSON ACTIVATION (subthresh)
n=5;                                                         % loop to run and safe simulation piece-wise % max n=length(tree)
for counter=1:n:length(tree)
    counter
cells                    = tree(counter:counter+n-1);        % tree morphologies without the source stimulation cells
freq                     = 1;                                % frequency that lead to a subthreshold response using the subthreshold weigth
stimnum                  = 1e9;
syn_weight               = 0.00025;                          % weigth for the active model
with_nmda                = 0;                                % with NMDA synapses
cluster_syn              = 0;                                % clustered stimulation of apical subtree (10 syns)
syn_nmda                 = syn_weight * 1.08;                % nmda weights
inhib_syns               = 0;                                % with inhibitory syns
noise                    = 1;
syn_dens                 = 1;                                % Synapse per µm dendritic path length (all regions have same density)
N                        = 1;                                % Number of Simulations
regions                  = {'basal', 'trunk', 'peritrunk', 'apical'};   % Regions where synapses should be placed
for t                    = 1 : numel (cells)
    % array with as many zeros as nodes in the cells:
    dend{t}              = zeros (size (cells{t}.X), 'double');
    for sim              = 1 : numel (regions)
        % Get ones in the regions you want to activate:
        dend{t}          = dend{t} + double ( cells{t}.R (:) == find (strcmp (regions{sim}, cells{t}.rnames)));
    end
    % Get ones in the regions you do not want to activate:
    rest{t}              = double (abs (dend{t}-ones (size (cells{t}.X), 'double')));
    % Calculate the length of each group of regions in order to be able to
    % activate per density:
    dendlength (t)       = sum (len_tree (cells{t}).*dend{t});                    
    restlength (t)       = sum (len_tree (cells{t}).*rest{t});
end
nsyn_max                 = ceil (max (cellfun (@(x) sum (len_tree (x)), cells)-restlength') * max(syn_dens));  % Get the maximum number of synapses you will get with you conditions
% create as many artificial cells as synapses on the trees (take the tree with the maximum number of synapses)
cells (numel (cells) + 1 : numel (cells) + 1 + nsyn_max) = ...
    {(struct ( ...
    'artificial',          'NetStim', ...
    'start',               50, ...
    'interval',            1 / freq * 1000, ...
    'number',              stimnum, ...
    'noise',               noise, ...
    'seed',                '(1)'))};

thesesynids  = cell (numel (cells(1:n)), 1);
nsyn = cell (numel (cells(1:n)), 1);
for t = 1:numel (cells(1:n))
    neuronn{t} = neuron;
    neuronn{t}.mech             = neuron.mech(counter:counter+n-1);
    %     iseg_nodes{t} = find(cells{t}.R == find(strcmp(cells{t}.rnames, 'iseg')));
    %     recnodes{t} = [1, iseg_nodes{t}(end)];   % measure at the end of the iseg region
    [~, i1]              = max (cells{t}.Y);
    recnodes             = [1 i1];
    neuronn{t}.record{t}.cell = struct('node',recnodes,'record',{'v'});
    %Synapse distribution
    if cluster_syn==0
        [nsyn{t}, thesesynids{t}, syndens{t}] = getsynnum (cells{t}, syn_dens, regions); % get the synaptic IDs
    else
        % Regions where subtree cluster should be placed
        apical_regions  = {'proxAp','middleAp','distalAp','tuft'};   
        apical_dend{t}  = zeros (size (cells{t}.X), 'double');
        for sim         = 1 : numel (apical_regions)
            apical_dend{t}  = apical_dend{t} + double ( cells{t}.R (:) == find (strcmp (apical_regions{sim}, cells{t}.rnames)));
        end
        %apical_dendlength(t) = sum (len_tree (cells{t}).*apical_dend{t});  
        total_length         = sum (len_tree (cells{t}));  
        % Percentage of apical tree to be activated
        activate_percent     = 0.2;
        cluster{t}    = apical_dend{t};
        % All branches
        [~,vec]       = dissect_tree(cells{t});        
        % Remove furthest branches until cluster in apical dendrites is as short as wanted
        while sum (len_tree (cells{t}).*cluster{t}) > activate_percent * total_length
            highest_branch_order = max(vec(:,1).*cluster{t});
            cluster{t} = cluster{t}.*(logical(vec(:,1)-highest_branch_order));
        end
        % Add last branch part that was removed too much
        error_len = round(activate_percent * total_length - sum (len_tree (cells{t}).*cluster{t}));
        if error_len>0
        last_branch = find(~logical(vec(:,1)-highest_branch_order),error_len);
        cluster{t}(last_branch) = 1;
        end
        thesesynids{t}=(1:numel(cells{t}.X))';
        thesesynids{t}=nonzeros(thesesynids{t}.*cluster{t});
        nsyn{t}=cluster{t};% since we take one syn per node anyway
    end
    nsyn_old{t}=nsyn{t};
    tags_ampa                   = string(compose('Tree%03d_synampa%d',t,1:numel(thesesynids{t})))';
    neuronn{t}.pp{t}.Exp2Syn(1) = struct ( ...
        'node',            thesesynids{t}, ...
        'tag',             tags_ampa, ...
        'tau1',            0.2, ...
        'tau2',            2.5, ...
        'e',               0);
    neuronn{t}.con(1 : numel(thesesynids{t})) = struct( ...
        'source',          struct ( ...
        'cell',            NaN, ...
        'watch',           'on'), ...
        'target',          struct ( ...
        'cell',            t, ...
        'pp',              'Exp2Syn', ...
        'node',            NaN), ...
        'weight',          syn_weight, ...
        'delay',           0, ...
        'threshold',       0.5);
    nneuron{t}.custom{t}       = [];
    for sim    = 1 : numel (thesesynids{t})
        neuronn{t}.con(sim).source.cell  = sim + numel (cells(1:n));     % the "n" artificial cell, is connected to
        neuronn{t}.con(sim).target.node  = thesesynids{t}(sim);     % the "n" synaptic node of the tree "t"
        % hack to come around the problem if more than one PP of the
        % same PP group is defined at the same node:
        neuronn{t}.con(sim).target.ipp   = nsyn_old {t}(thesesynids{t} (sim));
        nsyn_old{t} (thesesynids{t} (sim))  = nsyn_old{t} (thesesynids{t} (sim)) - 1;
    end
    
end
%%%% NMDA SYNAPSES
if with_nmda
for t = 1:numel(cells(1:n))
    prev_con_size{t} = size(neuronn{t}.con,2);
end
for t = 1:numel (cells(1:n))
    tags_nmda                   = string(compose('Tree%03d_synnmda%d',t,1:numel(thesesynids{t})))';
    nsyn_old{t}=nsyn{t};
    % NMDA SYNAPSE
    neuronn{t}.pp{t}.Exp2nmda2(1) = struct ( ...
        'node',            thesesynids{t}, ...
        'tag',             tags_nmda, ...
        'tau1',            0.33, ...
        'tau2',            50, ...
        'mg',              2, ...
        'eta',             0.05,...
        'gamma',           0.06, ...
        'gmax',            syn_nmda, ...
        'e',               0);
    neuronn{t}.con(prev_con_size{t}+1:prev_con_size{t}+numel(thesesynids{t})) = struct( ...
        'source',          struct ( ...
        'cell',            NaN, ...
        'watch',           'on'), ...
        'target',          struct ( ...
        'cell',            t, ...
        'pp',              'Exp2nmda2', ...
        'tag',             NaN), ...
        'weight',          syn_nmda, ...
        'delay',           0.05, ...
        'threshold',       0.5);
    % Connecting the artificial cell to the nodes where the synapses are placed: 
    for sim    = 1 : numel (thesesynids{t})  
        neuronn{t}.con(prev_con_size{t}+sim).source.cell  = sim + numel (cells(1:n));     % the "n" artificial cell, is connected to
        neuronn{t}.con(prev_con_size{t}+sim).target.tag  = tags_nmda (sim);      % the "n" synaptic node of the tree "t"
        % hack to come around the problem if more than one PP of the
        % same PP group is defined at the same node:
        neuronn{t}.con(prev_con_size{t}+sim).target.ipp   = nsyn_old {t}(thesesynids{t} (sim));
        nsyn_old{t} (thesesynids{t} (sim))   = nsyn_old{t} (thesesynids{t} (sim)) - 1;
    end
end
end

for counter3      = numel(cells(1:n))+1:numel(cells)    % for every artificial cell, you set the interval and the seed
    tree{counter3}.interval = 1/freq*1000;
end
% Inhibitory syns with E= -65, 20% of all syns
if inhib_syns
    for t                = 1 : numel (cells(1:n))
    E = (rand (numel (thesesynids{t}), 1)>0.8) * (-65);
    neuronn{t}.pp{t}.Exp2Syn.e = E;
    end 
end
out              = t2n (neuronn,cells, '-d-w-q');
%V                = zeros (length (time) ,length (out));
for counter2      = 1 : length (out)
    V (:, counter+counter2-1) = out{counter2}.record{counter2}.cell.v{recnodes};
    VD(:, counter+counter2-1) = out{counter2}.record{counter2}.cell.v{end};
end
end
time             = out{1}.t;
save             (['./data/',neuron.experiment], 'time', 'V', 'VD');
%%
clf; hold on;
plot                     (time, out{1}.record{1}.cell.v{1}, 'k')
plot                     (time, out{1}.record{1}.cell.v{end}, 'r')
plot                     (time, ...
    convn (out{1}.record{1}.cell.v{end}, ones (500,1)/500,'same'), 'g')

%%
clf; hold on;
plot                     (time, out{2}.record{2}.cell.v{1}, 'k')
plot                     (time, out{2}.record{2}.cell.v{end}, 'r')
plot                     (time, ...
    convn (out{2}.record{2}.cell.v{end}, ones (500,1)/500,'same'), 'g')



